#!/bin/bash

set -e

# Check for --auto-close flag and temp file
AUTO_CLOSE=false
TEMP_FILE=""
if [ "$1" = "--auto-close" ]; then
    AUTO_CLOSE=true
    TEMP_FILE="$2"
fi

# Function to signal completion on exit
cleanup() {
    if [ "$AUTO_CLOSE" = true ] && [ -n "$TEMP_FILE" ]; then
        echo "setup_complete" > "$TEMP_FILE"
    fi
}

# Set trap to call cleanup on exit
if [ "$AUTO_CLOSE" = true ]; then
    trap cleanup EXIT
fi

echo "ðŸš€ Databricks App Template Setup"
echo "================================="

# Get the directory of this script
SETUP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source shared utilities
source "$SETUP_DIR/setup_utils/utils.sh"

# Check for required tools
echo ""
echo "ðŸ”§ Checking System Dependencies"
echo "================================"
echo ""

OS=$(get_os)
echo "ðŸ–¥ï¸  Detected OS: $OS"
echo ""

# Check dependencies in the right order
echo "ðŸº Checking Homebrew (macOS only)..."
if ! source "$SETUP_DIR/setup_utils/check_homebrew.sh" && check_homebrew; then
    exit 1
fi

echo ""
echo "ðŸ“ Checking Git..."
if ! source "$SETUP_DIR/setup_utils/check_git.sh" && check_git; then
    exit 1
fi

echo ""
echo "ðŸ“¦ Checking uv (Python package manager)..."
if ! source "$SETUP_DIR/setup_utils/check_uv.sh" && check_uv; then
    exit 1
fi


echo ""
echo "ðŸš€ Checking Bun (JavaScript package manager)..."
if ! source "$SETUP_DIR/setup_utils/check_bun.sh" && check_bun; then
    exit 1
fi

echo ""
echo "ðŸŸ¢ Checking Node.js 18+..."
if ! source "$SETUP_DIR/setup_utils/check_node.sh" && check_node; then
    exit 1
fi

echo ""
echo "ðŸ”§ Checking Databricks CLI..."
if ! source "$SETUP_DIR/setup_utils/check_databricks.sh" && check_databricks; then
    exit 1
fi

echo ""
echo "ðŸŽ‰ All required system dependencies are installed!"
echo ""

# Function to prompt for input with default value
prompt_with_default() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    
    read -p "$prompt [$default]: " input
    if [ -z "$input" ]; then
        input="$default"
    fi
    
    # Set the variable dynamically
    eval "$var_name='$input'"
}

# Function to update or add a value in .env.local
update_env_value() {
    local key="$1"
    local value="$2"
    local comment="$3"
    
    if grep -q "^${key}=" .env.local 2>/dev/null; then
        # Update existing value
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS sed
            sed -i '' "s|^${key}=.*|${key}=${value}|" .env.local
        else
            # Linux sed
            sed -i "s|^${key}=.*|${key}=${value}|" .env.local
        fi
    else
        # Add new value with comment if provided
        if [ -n "$comment" ]; then
            echo "" >> .env.local
            echo "# $comment" >> .env.local
        fi
        echo "${key}=${value}" >> .env.local
    fi
}

# Function to test databricks connection
test_databricks_connection() {
    local profile="$1"
    echo "ðŸ” Testing Databricks connection..."
    
    # Ensure environment variables are exported for databricks CLI
    if [ -n "$DATABRICKS_HOST" ] && [ -n "$DATABRICKS_TOKEN" ]; then
        export DATABRICKS_HOST
        export DATABRICKS_TOKEN
    fi
    
    if [ -n "$profile" ]; then
        if databricks current-user me --profile "$profile" >/dev/null 2>&1; then
            echo "âœ… Successfully connected to Databricks with profile '$profile'"
            return 0
        else
            echo "âŒ Failed to connect to Databricks with profile '$profile'"
            return 1
        fi
    else
        if databricks current-user me >/dev/null 2>&1; then
            echo "âœ… Successfully connected to Databricks"
            return 0
        else
            echo "âŒ Failed to connect to Databricks"
            return 1
        fi
    fi
}

# Check if .env.local already exists
if [ -f ".env.local" ]; then
    echo "ðŸ“‹ Found existing .env.local file."
    read -p "Do you want to update it? (y/N): " update_env
    if [[ ! "$update_env" =~ ^[Yy]$ ]]; then
        echo "Skipping environment configuration."
        skip_env=true
    fi
fi

if [ "$skip_env" != "true" ]; then
    echo "âš™ï¸  Setting up environment variables..."
    
    # Load existing values if they exist
    if [ -f ".env.local" ]; then
        source .env.local 2>/dev/null || true
    fi
    
    # Initialize .env.local file if it doesn't exist
    if [ ! -f ".env.local" ]; then
        echo "# Databricks App Configuration" > .env.local
        echo "# Generated by setup script on $(date)" >> .env.local
        echo "" >> .env.local
    fi
    
    # Databricks Authentication Configuration
    echo ""
    echo "ðŸ” Databricks Authentication"
    echo "-----------------------------"
    echo "Choose authentication method:"
    echo "1. Personal Access Token (PAT)"
    echo "2. Configuration Profile"
    echo ""
    
    # Pre-select based on existing configuration
    if [ "$DATABRICKS_AUTH_TYPE" = "pat" ]; then
        default_choice="1"
    elif [ "$DATABRICKS_AUTH_TYPE" = "databricks-cli" ]; then
        default_choice="2"
    else
        default_choice=""
    fi
    
    if [ -n "$default_choice" ]; then
        prompt_with_default "Select option" "$default_choice" "auth_choice"
    else
        read -p "Select option (1 or 2): " auth_choice
    fi
    
    if [ "$auth_choice" = "1" ]; then
        # PAT Authentication
        echo ""
        echo "ðŸ“ Personal Access Token Setup"
        echo "-------------------------------"
        
        # Update auth type in .env.local
        update_env_value "DATABRICKS_AUTH_TYPE" "pat" "Databricks Authentication Type"
        
        if [ -z "$DATABRICKS_HOST" ]; then
            prompt_with_default "Databricks Host" "https://your-workspace.cloud.databricks.com" "DATABRICKS_HOST"
        else
            prompt_with_default "Databricks Host" "$DATABRICKS_HOST" "DATABRICKS_HOST"
        fi
        
        # Update host in .env.local
        update_env_value "DATABRICKS_HOST" "$DATABRICKS_HOST" "Databricks Configuration (PAT mode)"
        
        if [ -n "$DATABRICKS_TOKEN" ]; then
            echo "Found existing token: ${DATABRICKS_TOKEN:0:10}... (truncated)"
            read -p "Use existing token? (y/N): " use_existing
            if [[ ! "$use_existing" =~ ^[Yy]$ ]]; then
                DATABRICKS_TOKEN=""
            fi
        fi
        
        if [ -z "$DATABRICKS_TOKEN" ]; then
            echo ""
            echo "You can create a Personal Access Token here:"
            echo "ðŸ“– $DATABRICKS_HOST/settings/user/developer/access-tokens"
            echo ""
            read -s -p "Databricks Personal Access Token: " DATABRICKS_TOKEN
            echo ""
        fi
        
        # Update token in .env.local
        update_env_value "DATABRICKS_TOKEN" "$DATABRICKS_TOKEN"
        
        # Set empty profile to indicate PAT mode
        DATABRICKS_CONFIG_PROFILE=""
        DATABRICKS_AUTH_TYPE="pat"
        
        # Test PAT authentication
        echo "ðŸ” Testing PAT authentication..."
        export DATABRICKS_HOST="$DATABRICKS_HOST"
        export DATABRICKS_TOKEN="$DATABRICKS_TOKEN"
        
        echo "Attempting to connect with:"
        echo "Host: $DATABRICKS_HOST"
        echo "Token: ${DATABRICKS_TOKEN:0:10}... (truncated)"
        echo ""
        
        # Test connection and show output for debugging
        echo "Running: databricks current-user me"
        # Export for databricks CLI
        export DATABRICKS_HOST="$DATABRICKS_HOST"
        export DATABRICKS_TOKEN="$DATABRICKS_TOKEN"
        if databricks current-user me >/dev/null 2>&1; then
            echo "âœ… Successfully connected to Databricks with PAT"
        else
            echo ""
            echo "âŒ PAT authentication failed."
            echo "Please check your host URL and token are correct."
            echo "You can test manually with:"
            echo "DATABRICKS_HOST='$DATABRICKS_HOST' DATABRICKS_TOKEN='$DATABRICKS_TOKEN' databricks current-user me"
            exit 1
        fi
        
    elif [ "$auth_choice" = "2" ]; then
        # Profile Authentication
        echo ""
        echo "ðŸ“‹ Configuration Profile Setup"
        echo "-------------------------------"
        
        # Update auth type in .env.local
        update_env_value "DATABRICKS_AUTH_TYPE" "databricks-cli" "Databricks Authentication Type"
        
        # List existing profiles
        printf "Loading profiles... "
        PROFILES_OUTPUT=$(databricks auth profiles 2>/dev/null)
        printf "âœ“\n"
        if [ $? -eq 0 ] && [ -n "$PROFILES_OUTPUT" ]; then
            echo "$PROFILES_OUTPUT"
        else
            echo "No existing profiles found"
        fi
        echo ""
        
        prompt_with_default "Databricks Config Profile" "${DATABRICKS_CONFIG_PROFILE:-DEFAULT}" "DATABRICKS_CONFIG_PROFILE"
        
        # Update profile in .env.local
        update_env_value "DATABRICKS_CONFIG_PROFILE" "$DATABRICKS_CONFIG_PROFILE" "Databricks Configuration (Profile mode)"
        
        # Clear PAT credentials when using profile
        update_env_value "DATABRICKS_HOST" ""
        update_env_value "DATABRICKS_TOKEN" ""
        DATABRICKS_HOST=""
        DATABRICKS_TOKEN=""
        DATABRICKS_AUTH_TYPE="databricks-cli"
        
        # Test profile authentication
        if ! test_databricks_connection "$DATABRICKS_CONFIG_PROFILE"; then
            echo ""
            echo "Profile '$DATABRICKS_CONFIG_PROFILE' not found or invalid."
            echo "Would you like to login to this profile now? (y/N)"
            read -p "> " login_profile
            
            if [[ "$login_profile" =~ ^[Yy]$ ]]; then
                echo "Running 'databricks auth login --profile $DATABRICKS_CONFIG_PROFILE'..."
                databricks auth login --profile "$DATABRICKS_CONFIG_PROFILE"
                
                # Test again after login
                if ! test_databricks_connection "$DATABRICKS_CONFIG_PROFILE"; then
                    echo "âŒ Profile login failed or connection test failed. Please check your settings."
                    exit 1
                else
                    echo "âœ… Successfully logged in to profile '$DATABRICKS_CONFIG_PROFILE'"
                fi
            else
                echo "âŒ Valid Databricks authentication is required for deployment."
                exit 1
            fi
        fi
        
    else
        echo "âŒ Invalid option. Please run setup again."
        exit 1
    fi
    
    # Get current user information (only if we don't have existing DBA_SOURCE_CODE_PATH)
    if [ -z "$DBA_SOURCE_CODE_PATH" ]; then
        echo ""
        echo "ðŸ” Getting user information..."
        
        if [ "$DATABRICKS_AUTH_TYPE" = "databricks-cli" ]; then
            DATABRICKS_USER=$(databricks current-user me --profile "$DATABRICKS_CONFIG_PROFILE" --output json 2>/dev/null | grep -o '"userName":"[^"]*"' | cut -d'"' -f4)
        else
            # For PAT auth, ensure environment variables are exported
            export DATABRICKS_HOST="$DATABRICKS_HOST"
            export DATABRICKS_TOKEN="$DATABRICKS_TOKEN"
            DATABRICKS_USER=$(databricks current-user me --output json 2>/dev/null | grep -o '"userName":"[^"]*"' | cut -d'"' -f4)
        fi
        
        if [ -n "$DATABRICKS_USER" ]; then
            echo "âœ… Detected user: $DATABRICKS_USER"
        else
            echo "âš ï¸  Could not detect user, will use default email"
        fi
    else
        echo ""
        echo "âœ… Using existing configuration from .env.local"
    fi
    
    # App Configuration
    echo ""
    echo "ðŸš€ App Configuration"
    echo "--------------------"
    echo "If you haven't created a Databricks App yet, don't worry - the deploy script will create it for you!"
    echo "You can also create a custom app manually from the UI if you prefer:"
    
    # Get workspace URL based on auth type
    if [ "$DATABRICKS_AUTH_TYPE" = "databricks-cli" ] && [ -n "$DATABRICKS_CONFIG_PROFILE" ]; then
        WORKSPACE_HOST=$(databricks auth profiles 2>/dev/null | grep "^$DATABRICKS_CONFIG_PROFILE " | awk '{print $2}')
    elif [ "$DATABRICKS_AUTH_TYPE" = "pat" ] && [ -n "$DATABRICKS_HOST" ]; then
        WORKSPACE_HOST="$DATABRICKS_HOST"
    fi
    
    if [ -n "$WORKSPACE_HOST" ]; then
        echo "ðŸ“– $WORKSPACE_HOST/apps/create"
    else
        echo "ðŸ“– https://your-workspace.cloud.databricks.com/apps/create"
    fi
    echo ""
    prompt_with_default "App Name for Deployment" "${DATABRICKS_APP_NAME:-my-databricks-app}" "DATABRICKS_APP_NAME"
    
    # Update the default source path to use the chosen app name
    if [ -z "$DBA_SOURCE_CODE_PATH" ]; then
        if [ -n "$DATABRICKS_USER" ]; then
            DEFAULT_SOURCE_PATH="/Workspace/Users/$DATABRICKS_USER/$DATABRICKS_APP_NAME"
        else
            DEFAULT_SOURCE_PATH="/Workspace/Users/<your-email@company.com>/$DATABRICKS_APP_NAME"
        fi
    else
        DEFAULT_SOURCE_PATH="$DBA_SOURCE_CODE_PATH"
    fi
    
    prompt_with_default "Source Code Path for Deployment" "$DEFAULT_SOURCE_PATH" "DBA_SOURCE_CODE_PATH"
    
    # Update app configuration in .env.local
    update_env_value "DATABRICKS_APP_NAME" "$DATABRICKS_APP_NAME" "Databricks App Configuration"
    update_env_value "DBA_SOURCE_CODE_PATH" "$DBA_SOURCE_CODE_PATH"
    
    echo ""
    echo "âœ… Environment configuration saved to .env.local"
fi

# Install Python dependencies
echo "ðŸ“¦ Installing Python dependencies..."
uv sync --dev

# Install frontend dependencies
echo "ðŸ“¦ Installing frontend dependencies..."
if command -v bun >/dev/null 2>&1; then
    cd client
    bun install
    cd ..
    echo "âœ… Frontend dependencies installed successfully!"
else
    echo ""
    echo "âŒ Bun is not installed, but it's required to install frontend dependencies."
    echo "ðŸ“‹ Frontend dependencies are essential for this project to work properly."
    echo ""
    read -p "ðŸ¤” Would you like me to install Bun for you now? (y/N): " install_bun
    
    if [[ "$install_bun" =~ ^[Yy]$ ]]; then
        echo "ðŸš€ Installing Bun..."
        if [[ "$OS" == "macOS" ]]; then
            if command -v brew >/dev/null 2>&1; then
                brew tap oven-sh/bun && brew install bun
            else
                curl -fsSL https://bun.sh/install | bash
            fi
        else
            curl -fsSL https://bun.sh/install | bash
        fi
        
        # Source shell configuration to update PATH
        if [ -f "$HOME/.bashrc" ]; then
            source "$HOME/.bashrc"
        fi
        if [ -f "$HOME/.zshrc" ]; then
            source "$HOME/.zshrc"
        fi
        export PATH="$HOME/.bun/bin:$PATH"
        
        # Verify installation and install dependencies
        if command -v bun >/dev/null 2>&1; then
            echo "âœ… Bun installed successfully!"
            cd client
            bun install
            cd ..
            echo "âœ… Frontend dependencies installed successfully!"
        else
            echo "âŒ Failed to install Bun. Please install it manually and re-run this script."
            echo "Visit: https://bun.sh/docs/installation"
            exit 1
        fi
    else
        echo "âŒ Cannot proceed without Bun. Frontend dependencies are required."
        echo "ðŸ’¡ Install Bun manually and re-run this setup script:"
        echo "   curl -fsSL https://bun.sh/install | bash"
        echo "   ./setup.sh"
        exit 1
    fi
fi

# Install Playwright browsers (if Playwright is in dependencies)
echo ""
echo "ðŸŽ­ Installing Playwright browsers..."
if [ -f "client/package.json" ] && grep -q "@playwright/test" client/package.json; then
    echo "ðŸ“‹ Found Playwright in client dependencies, installing browsers..."
    cd client
    if npx playwright install; then
        echo "âœ… Playwright browsers installed successfully!"
    else
        echo "âš ï¸  Failed to install Playwright browsers. You can install them later with:"
        echo "   cd client && npx playwright install"
    fi
    cd ..
elif [ -f "package.json" ] && grep -q "@playwright/test" package.json; then
    echo "ðŸ“‹ Found Playwright in root dependencies, installing browsers..."
    if npx playwright install; then
        echo "âœ… Playwright browsers installed successfully!"
    else
        echo "âš ï¸  Failed to install Playwright browsers. You can install them later with:"
        echo "   npx playwright install"
    fi
else
    echo "ðŸ’¡ Playwright not found in dependencies - browsers not installed"
    echo "   If you add Playwright later, run: npx playwright install"
fi

echo ""
echo "ðŸŽ‰ Setup complete!"
echo ""
echo "âš ï¸  IMPORTANT: Please restart Claude Code to enable MCP Playwright integration"
echo ""
echo "Next steps:"
echo "1. Restart Claude Code (close and reopen the application)"
echo "2. Run './watch.sh' to start the development servers"
echo "3. Open http://localhost:3000 to view the app"
echo "4. Open http://localhost:8000/docs to view the API documentation"
echo ""
echo "Optional:"
echo "- Run './fix.sh' to format your code"
echo "- Edit .env.local to update configuration"

# Auto-close terminal if flag is set
if [ "$AUTO_CLOSE" = true ]; then
    echo ""
    echo "Press Enter to close this terminal..."
    read
    
    # Only attempt to close on macOS where osascript is available
    if command -v osascript >/dev/null 2>&1; then
        # Close appropriate terminal app
        if [ -d "/Applications/iTerm.app" ]; then
            # For iTerm, close the current window
            osascript -e 'tell application "iTerm" to close current window' 2>/dev/null || true
        elif [ -d "/Applications/Terminal.app" ]; then
            # For Terminal, close windows containing setup.sh
            osascript -e 'tell application "Terminal" to close (every window whose name contains "setup.sh")' 2>/dev/null || true
        fi
    fi
fi

